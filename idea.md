# Техническое Задание: Плагин ограничения доступа к страницам и записям

## 1. Назначение и Описание

### 1.1 Цель разработки
Создать WordPress плагин, который позволяет администратору сайта точечно ограничивать доступ пользователей с ролью `Editor` к просмотру и редактированию конкретных страниц и записей в админ-панели. Пользователь видит в списках только те посты/страницы, которые ему явно разрешены администратором.

### 1.2 Проблема, которую решает плагин
В стандартной WordPress роли `Editor` пользователь видит ВСЕ страницы и записи на сайте. Нужна возможность:
- Дать разработчику/верстальщику доступ только к конкретным страницам
- Скрыть все остальные страницы и записи из списков в админке
- Запретить прямой доступ к скрытым страницам (через URL-адрес)

### 1.3 Целевая аудитория
- Администратор сайта (управляет доступом)
- Верстальщик/разработчик (роль Editor, ограниченный доступ)

---

## 2. Функциональные требования

### 2.1 Управление доступом (админ-панель)

#### 2.1.1 Интерфейс управления
**Локация**: Новый раздел меню админ-панели: `Параметры → Ограничение доступа к контенту` (или `Settings → Content Access Restriction`)

**Функционал:**
- Список всех пользователей с ролью `Editor` на сайте
- Для каждого пользователя:
  - Чекбокс для выбора пользователя
  - Две отдельные секции: 
    - **Разрешенные страницы** (Pages)
    - **Разрешенные записи** (Posts)
  
**Интерфейс выбора контента:**
- Мультиселект или список чекбоксов с поиском/фильтром
- Каждый элемент отображает: `[ID] Заголовок` + статус публикации (Published/Draft/Pending)
- Кнопки: "Выбрать все", "Очистить выбор"

#### 2.1.2 Сохранение прав доступа
- Данные о разрешенных страницах/записях хранятся в `wp_usermeta` с префиксом `restricted_pages_allowed_{page|post}`
- Формат: массив ID разрешенных страниц/записей на каждого пользователя
- При сохранении: валидация ID, проверка что пост/страница существует

#### 2.1.3 Визуализация
- Таблица пользователей с иконками статуса рядом (✓ для назначенных прав)
- Счетчик разрешенных страниц/записей рядом с каждым пользователем
- Сообщение об успешном сохранении

### 2.2 Ограничение видимости в админке

#### 2.2.1 Фильтрация списков в админке

**Для пользователей с ролью Editor (не администраторы):**

**Скрытие из списков:**
- При открытии `edit.php?post_type=page` — показать только разрешенные страницы
- При открытии `edit.php` (записи) — показать только разрешенные записи
- Все остальные посты/страницы должны быть полностью скрыты из списка

**Реализация:**
- Хук `pre_get_posts` — добавить в query параметр `post__in` с массивом разрешенных ID
- Если нет разрешенных ID — показать пустой список (вместо всех постов)

#### 2.2.2 Блокировка прямого доступа к скрытым страницам

**Сценарий:** Пользователь пытается открыть редактор страницы по прямой ссылке (`post.php?post=123&action=edit`), хотя ему эта страница не разрешена.

**Поведение:**
- Перехват на хуке `load-post.php` или `current_screen`
- Проверка: есть ли у текущего пользователя доступ к этому ID?
- Если НЕТ доступа:
  - Редирект на список страниц/записей с сообщением об ошибке
  - Сообщение: "У вас нет доступа к этому контенту"
  - HTTP код 403 (Forbidden)

#### 2.2.3 Скрытие в метабоксах и выпадающих списках

**Где скрывать:**
- Родительская страница (Parent) в метабоксе "Атрибуты страницы" — показать только разрешенные родительские страницы
- Если пытается установить родителем неразрешенную страницу — запретить сохранение

**Реализация:**
- Хук `page_attributes_dropdown_pages_args` для фильтрации dropdown'а родительских страниц
- Фильтр `wp_dropdown_pages` или прямая фильтрация массива в функции

### 2.3 Логирование и аудит (опционально, версия 1.1)

**Минимум:**
- Логировать каждый раз при попытке доступа к скрытой странице (админ может видеть)
- Логировать изменения прав доступа (кто и когда изменил)

---

## 3. Не-функциональные требования

### 3.1 Совместимость
- WordPress 5.8+
- PHP 7.4+
- Совместимость с Elementor (не должен конфликтовать при открытии Elementor Editor)
- Совместимость с User Role Editor и другими плагинами управления ролями

### 3.2 Безопасность
- Проверка nonce при всех POST-запросах в админке
- Проверка прав пользователя (`current_user_can('manage_options')`) перед отображением интерфейса управления
- Валидация всех ID постов/страниц перед использованием в queries
- Escapement всех выводимых данных (esc_html, esc_url и т.д.)
- Sanitization всех входных данных ($_POST, $_GET)

### 3.3 Производительность
- Кэширование списков разрешенных страниц в транзиентах (cache busting при изменении прав)
- Избежать N+1 queries при выборке пользователей и их прав
- Оптимизированные SQL-запросы

### 3.4 Совместимость с API
- REST API: Если пользователь обращается к скрытым постам через REST API — возвращать 403 Forbidden или не включать в списки
- Проверка на хуке `rest_prepare_post` или в фильтре доступа

### 3.5 Локализация
- Все текстовые строки должны быть готовы к переводу (использовать `__()`, `_e()`, `esc_html__()`)
- Готовые переводы: русский, английский

---

## 4. Технические требования и архитектура

### 4.1 Структура плагина

restricted-pages-access/
├── restricted-pages-access.php          # Главный файл плагина
├── readme.txt                           # Описание для каталога
├── includes/
│   ├── class-admin-page.php            # Страница администратора (UI управления)
│   ├── class-access-filter.php         # Логика фильтрации списков постов
│   ├── class-post-access.php           # Проверка доступа к отдельным постам
│   ├── class-user-meta-handler.php     # Работа с user meta (хранение прав)
│   └── class-rest-api.php              # REST API фильтры (опционально)
├── assets/
│   ├── css/
│   │   └── admin-style.css
│   └── js/
│       └── admin-script.js             # JS для админ-интерфейса
├── templates/
│   └── admin-page.php                  # HTML шаблон страницы управления
├── languages/
│   ├── restricted-pages-access-ru_RU.po
│   └── restricted-pages-access-en_US.po
└── .gitignore

### 4.2 Основные классы и их функции

#### 4.2.1 Class: Restricted_Pages_Access (главный класс)
**Файл:** `restricted-pages-access.php`

**Методы:**
- `__construct()` — инициализация плагина, регистрация хуков
- `activate()` — при активации (создание нужных таблиц/опций)
- `deactivate()` — при деактивации
- `load_plugin_textdomain()` — локализация

#### 4.2.2 Class: RPA_Admin_Page
**Файл:** `includes/class-admin-page.php`

**Задача:** Отобразить интерфейс управления в админке

**Методы:**
- `__construct()` — регистрация меню, подменю
- `register_menu()` — добавить "Параметры → Ограничение доступа"
- `render_admin_page()` — вывести HTML с интерфейсом
- `get_all_editors()` — получить список всех пользователей с ролью Editor
- `get_user_allowed_pages()` — получить разрешенные страницы для пользователя
- `get_user_allowed_posts()` — получить разрешенные записи для пользователя
- `save_access_settings()` — обработчик POST-запроса для сохранения прав
- `enqueue_scripts_and_styles()` — загрузить CSS/JS для интерфейса

#### 4.2.3 Class: RPA_Access_Filter
**Файл:** `includes/class-access-filter.php`

**Задача:** Фильтровать списки постов в админке

**Методы:**
- `__construct()` — регистрация фильтра на `pre_get_posts`
- `filter_posts_query()` — основной обработчик для фильтрации query
  - Проверить: текущий пользователь не админ?
  - Получить его разрешенные ID
  - Добавить `post__in` параметр в query
- `should_filter_user()` — является ли текущий пользователь Editor (не админ)?

#### 4.2.4 Class: RPA_Post_Access
**Файл:** `includes/class-post-access.php`

**Задача:** Проверить доступ при открытии отдельного поста/страницы

**Методы:**
- `__construct()` — регистрация на `load-post.php`, `current_screen`
- `check_post_access()` — основная функция проверки
  - Получить текущий post ID из $_GET или $screen
  - Если пользователь не админ и пост не в его списке разрешенных:
    - Редирект на список постов/страниц
    - Вывести сообщение об ошибке
- `user_has_post_access()` — булева функция проверки доступа
- `get_user_allowed_post_ids()` — получить массив разрешенных ID для пользователя

#### 4.2.5 Class: RPA_User_Meta_Handler
**Файл:** `includes/class-user-meta-handler.php`

**Задача:** Работа с хранением и получением данных о доступе в user meta

**Методы:**
- `set_user_allowed_pages()` — сохранить массив разрешенных страниц для пользователя
- `set_user_allowed_posts()` — сохранить массив разрешенных записей
- `get_user_allowed_pages()` — получить массив разрешенных страниц
- `get_user_allowed_posts()` — получить массив разрешенных записей
- `clear_user_access()` — очистить все права доступа для пользователя
- `delete_user_access()` — удалить права при удалении пользователя

**Структура данных:**
user_id: 5 (Editor)
Meta key: 'rpa_allowed_pages' → значение: [12, 45, 67] (массив ID страниц)
Meta key: 'rpa_allowed_posts' → значение: [89, 102, 115] (массив ID записей)

#### 4.2.6 Class: RPA_REST_API (опционально)
**Файл:** `includes/class-rest-api.php`

**Задача:** Фильтрация REST API запросов

**Методы:**
- `register_rest_hooks()` — зарегистрировать фильтры
- `filter_rest_posts()` — фильтр на REST запросах к `/wp/v2/pages` и `/wp/v2/posts`

---

## 5. Алгоритмы и логика

### 5.1 Алгоритм фильтрации списков в админке

Пользователь открывает edit.php (список страниц/записей)
    ↓
Срабатывает хук pre_get_posts
    ↓
Проверка: текущий пользователь — админ?
├─ ДА → оставить query без изменений
└─ НЕТ (роль Editor/другая) → продолжить
    ↓
Получить из user meta массив разрешенных ID (например: [12, 45, 67])
    ↓
Добавить в query параметр: post__in = [12, 45, 67]
    ↓
Выполнить query с ограничением
    ↓
Вернуть только разрешенные посты/страницы

### 5.2 Алгоритм проверки при открытии отдельного поста

Пользователь переходит по ссылке: post.php?post=123&action=edit
    ↓
Срабатывает хук load-post.php
    ↓
Проверка: текущий пользователь — админ?
├─ ДА → позволить открыть
└─ НЕТ → продолжить
    ↓
Получить post ID из $_GET['post'] (ID = 123)
    ↓
Получить из user meta массив разрешенных ID (например: [12, 45, 67])
    ↓
Проверка: 123 находится в массиве [12, 45, 67]?
├─ ДА → позволить открыть
└─ НЕТ → редирект на edit.php с сообщением об ошибке (403)

### 5.3 Алгоритм сохранения прав доступа в админке

Администратор заполняет форму "Выбрать страницы для пользователя"
    ↓
Кликает кнопку "Сохранить"
    ↓
Срабатывает POST-запрос с nonce
    ↓
Проверка nonce и прав (current_user_can('manage_options'))
    ↓
Получить из $_POST массив выбранных ID (post__in)
    ↓
Валидировать каждый ID:
├─ Проверить что это число
├─ Проверить что такой пост/страница существует
└─ Если ошибка → отклонить
    ↓
Очистить старые права: delete_user_meta($user_id, 'rpa_allowed_pages')
    ↓
Сохранить новые права: update_user_meta($user_id, 'rpa_allowed_pages', [12, 45, 67])
    ↓
Вывести сообщение об успехе

---

## 6. Описание интерфейса управления

### 6.1 Главная страница: Список пользователей

**Путь:** Параметры → Ограничение доступа к контенту

**Элементы:**
1. **Заголовок:** "Ограничение доступа редакторов к контенту"
2. **Описание:** "Здесь вы можете ограничить доступ пользователей с ролью Editor к конкретным страницам и записям. Пользователь видит в админке только разрешенные вам страницы."
3. **Таблица пользователей:**
   - Столбец: Пользователь (ФИ + login)
   - Столбец: Email
   - Столбец: Разрешенные страницы (счетчик: "5 страниц")
   - Столбец: Разрешенные записи (счетчик: "3 записи")
   - Столбец: Действия (кнопка "Редактировать")

4. **Кнопка "Редактировать" → открыть модальное окно или новую страницу с полной формой**

### 6.2 Форма редактирования доступа пользователя

**Элементы:**
1. **Заголовок:** "Редактирование доступа: Иван Иванов (ivan_ivanov@mail.com)"
2. **Секция: Разрешенные страницы**
   - Поле поиска: фильтр по названию или ID
   - Таблица/список всех страниц:
     - Чекбокс + [ID] Название + статус (Published/Draft)
     - Кнопки: "Выбрать все", "Очистить выбор"
   - Выбранные страницы подсвечиваются

3. **Секция: Разрешенные записи**
   - Аналогично секции страниц

4. **Кнопки:**
   - "Сохранить" (POST запрос с nonce)
   - "Отмена" (вернуться к списку пользователей)

---

## 7. Детали реализации

### 7.1 Регистрация и инициализация плагина

**Главный файл: restricted-pages-access.php**

<?php
/**
 * Plugin Name: Restricted Pages Access
 * Description: Ограничение доступа редакторов к конкретным страницам и записям
 * Version: 1.0.0
 * Author: [Имя разработчика]
 * Text Domain: restricted-pages-access
 * Domain Path: /languages
 */

// Безопасность: проверить что это WordPress
if (!defined('ABSPATH')) {
    exit;
}

// Определить константы плагина
define('RPA_PLUGIN_DIR', plugin_dir_path(__FILE__));
define('RPA_PLUGIN_URL', plugin_dir_url(__FILE__));
define('RPA_VERSION', '1.0.0');

// Подключить классы (autoload или require)
require_once RPA_PLUGIN_DIR . 'includes/class-admin-page.php';
require_once RPA_PLUGIN_DIR . 'includes/class-access-filter.php';
require_once RPA_PLUGIN_DIR . 'includes/class-post-access.php';
require_once RPA_PLUGIN_DIR . 'includes/class-user-meta-handler.php';

// Инициализация при загрузке WordPress
add_action('plugins_loaded', function() {
    // Инициализировать каждый класс
    new RPA_Admin_Page();
    new RPA_Access_Filter();
    new RPA_Post_Access();
});

// Регистрация активации/деактивации
register_activation_hook(__FILE__, 'rpa_activate');
register_deactivation_hook(__FILE__, 'rpa_deactivate');

function rpa_activate() {
    // Создать нужные опции или таблицы
}

function rpa_deactivate() {
    // Очистить временные данные при необходимости
}

### 7.2 Фильтр на pre_get_posts (основная логика)

public function filter_posts_query($query) {
    // Пропустить админ и автосохранения
    if (is_admin() && !wp_doing_ajax()) {
        
        // Не трогать администраторов
        if (current_user_can('manage_options')) {
            return;
        }
        
        // Только для редакторов (можно расширить на другие роли)
        if (!user_can(wp_get_current_user(), 'edit_pages')) {
            return;
        }
        
        // Получить разрешенные ID для текущего пользователя
        $allowed_pages = get_user_meta(get_current_user_id(), 'rpa_allowed_pages', true);
        $allowed_pages = (is_array($allowed_pages)) ? $allowed_pages : [];
        
        // Если нет разрешенных страниц — показать пустой список
        if (empty($allowed_pages)) {
            $query->set('post__in', [0]); // 0 = ничего не покажет
        } else {
            $query->set('post__in', $allowed_pages);
        }
    }
}

### 7.3 Проверка при открытии поста

public function check_post_access() {
    global $post;
    
    // Пропустить администраторов
    if (current_user_can('manage_options')) {
        return;
    }
    
    // Получить ID открываемого поста
    $post_id = isset($_GET['post']) ? intval($_GET['post']) : null;
    
    if (!$post_id) {
        return;
    }
    
    // Получить разрешенные ID
    $allowed_pages = get_user_meta(get_current_user_id(), 'rpa_allowed_pages', true);
    $allowed_pages = (is_array($allowed_pages)) ? $allowed_pages : [];
    
    // Проверка доступа
    if (!in_array($post_id, $allowed_pages)) {
        wp_die('У вас нет доступа к этому контенту', 'Доступ запрещен', ['response' => 403]);
    }
}

---

## 8. Тестирование

### 8.1 Unit Tests
- Проверка функции получения разрешенных страниц
- Проверка функции сохранения прав
- Проверка функции валидации ID

### 8.2 Integration Tests
- Проверить что Editor видит только разрешенные страницы в admin edit.php
- Проверить что Editor не может открыть запрещенную страницу по прямой ссылке
- Проверить что администратор видит все страницы
- Проверить что при удалении пользователя его права удаляются

### 8.3 Manual Tests
- Создать тестового Editor'а
- Разрешить ему 3 страницы
- Проверить что в админке видит только 3 страницы
- Попробовать открыть запрещенную страницу по ссылке
- Проверить что не может отредактировать или удалить запрещенную страницу

---

## 9. Этапы разработки

### Этап 1: Базовая функциональность (MVP)
- [x] Создать интерфейс управления (админ-страница)
- [x] Реализовать сохранение прав в user meta
- [x] Реализовать фильтр lists на pre_get_posts
- [x] Реализовать проверку доступа при открытии поста

### Этап 2: Доработка и улучшение
- [ ] Локализация (русский/английский)
- [ ] REST API фильтры
- [ ] Улучшение UI (поиск, сортировка в списках)
- [ ] Логирование попыток доступа

### Этап 3: Опциональные функции (версия 1.1+)
- [ ] Поддержка других типов постов (Custom Post Types)
- [ ] Групповое управление доступом (группы пользователей)
- [ ] Интеграция с Elementor (проверка доступа в Elementor Editor)
- [ ] Admin Notice при попытке доступа к скрытому контенту

---

## 10. Приложение: Примеры использования

### Пример 1: Разработчик видит только две страницы
**Сценарий:**
1. Администратор заходит в Параметры → Ограничение доступа
2. Выбирает пользователя "Иван Иванов (Editor)"
3. Ставит чекбоксы на страницы:
   - [x] ID 12: "О компании"
   - [x] ID 45: "Услуги"
4. Кликает "Сохранить"

**Результат:**
- Иван заходит в админку
- В разделе Страницы видит только "О компании" и "Услуги"
- Все остальные страницы скрыты
- Если попробует перейти по прямой ссылке на другую страницу — получит ошибку 403

### Пример 2: Администратор видит все
**Сценарий:**
1. Администратор заходит в Параметры → Ограничение доступа
2. Видит все пользователей и их разрешенный контент
3. Может в любой момент отредактировать доступ (добавить или удалить страницы)

---

## 11. Критерии готовности (Definition of Done)

- [x] Код написан и протестирован разработчиком
- [x] Код соответствует WordPress coding standards
- [x] Все требования безопасности выполнены (nonce, valiation, sanitization)
- [x] Плагин тестирован на совместимость (WordPress 5.8+, PHP 7.4+)
- [x] Документация разработчика (код задокументирован в файлах)
- [x] Тестовые данные подготовлены
- [x] Плагин готов к деплою

---

## 12. Контактная информация

**Заказчик:** [Ваше имя]  
**Дата составления:** [Текущая дата]  
**Версия ТЗ:** 1.0